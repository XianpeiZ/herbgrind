#!/usr/bin/env python

#--------------------------------------------------------------------#
#--- HerbGrind: a valgrind tool for Herbie      mk_mathreplace.py ---#
#--------------------------------------------------------------------#


   # This file is part of HerbGrind, a valgrind tool for diagnosing
   # floating point accuracy problems in binary programs and extracting
   # problematic expressions.

   # Copyright (C) 2016 Alex Sanchez-Stern

   # This program is free software; you can redistribute it and/or
   # modify it under the terms of the GNU General Public License as
   # published by the Free Software Foundation; either version 3 of the
   # License, or (at your option) any later version.

   # This program is distributed in the hope that it will be useful, but
   # WITHOUT ANY WARRANTY; without even the implied warranty of
   # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   # General Public License for more details.

   # You should have received a copy of the GNU General Public License
   # along with this program; if not, write to the Free Software
   # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   # 02111-1307, USA.

   # The GNU General Public License is contained in the file COPYING.


class Op(object):
    def __init__(self, func, plain_name, nargs, mpfr_func=None, needsround=True):
        self.func = func
        self.nargs = nargs
        self.plain_name = plain_name
        self.needsround = needsround
        if (mpfr_func == None):
            self.mpfr_func = "mpfr_{}".format(func)
        else:
            self.mpfr_func = mpfr_func

def write_mathreplace_funcs(ops, fname):
    with open(fname, "x") as f:
        f.write("#ifndef _HG_MATHREPLACE_FUNCS\n")
        f.write("#define _HG_MATHREPLACE_FUNCS\n")
        f.write("\n")
        f.write("// This monstrosity of a file sets up a lot of the machinery to\n")
        f.write("// replace libm functions called by client programs with a call into\n")
        f.write("// tool code which handles them properly. Basically, I wanted to make\n")
        f.write("// it very easy to add new libm functions without having to change\n")
        f.write("// code in like four different places. So I took every place you would\n")
        f.write("// have to change code to add new functions, and abstraced them away\n")
        f.write("// into macros, which all live in this file. This means the rest of\n")
        f.write("// the project is agnostic to which functions from libm we support,\n")
        f.write("// but it also means there are mysterious macros scattered throughout\n")
        f.write("// that code, and this file is a giant mess. Luckily, you should never\n")
        f.write("// actually touch it yourself, because it's instead generated by the\n")
        f.write("// mk_mathreplace.py python script.\n")
        f.write("\n")
        f.write("// These operations are based on the ones that Herbie supports natively.\n")
        f.write("\n")

        f.write("// A list of all the unary operations, for the enum definition farther\n")
        f.write("// down in the file.\n")
        f.write("#define UNARY_OPS_LIST \\\n")
        for op in ops:
            if (op.nargs == 1):
                f.write("  OP_{}, \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A list of all the binary ops comma seperated, for the enum\n")
        f.write("// definition farther down in the file.\n")
        f.write("#define BINARY_OPS_LIST \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("  OP_{}, \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A list of all the binary ops comma seperated, for the enum\n")
        f.write("// definition farther down in the file.\n")
        f.write("#define TERNARY_OPS_LIST \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("   OP_{}, \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A bunch of case statements for each unary op whose mpfr function\n")
        f.write("// doesn't need a rounding mode, used in runtime/hg_mathreplace.c\n")
        f.write("#define UNARY_OPS_ROUND_CASES \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == True):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// Same as above, but for those that don't need a rounding mode.\n")
        f.write("#define UNARY_OPS_NOROUND_CASES \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == False):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// For places where we don't care about the rounding mode.\n")
        f.write("#define UNARY_OPS_CASES                         \\\n")
        f.write("  UNARY_OPS_ROUND_CASES                         \\\n")
        f.write("  UNARY_OPS_NOROUND_CASES\n")
        f.write("\n")

        f.write("// The binary operation cases, used in runtime/hg_mathreplace.c\n")
        f.write("#define BINARY_OPS_CASES \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// The ternary operation cases, used in runtime/hg_mathreplace.c\n")
        f.write("#define TERNARY_OPS_CASES \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A switch statement to populate the static information for the\n")
        f.write("// operations, plain_opname and op_symbol.\n")
        f.write("#define GET_OP_STATIC_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            f.write("    case OP_{}: \\\n".format(op.func.upper()))
            f.write("      plain_opname = \"{}\"; \\\n".format(op.plain_name))
            f.write("      op_symbol = \"{}\"; \\\n".format(op.func))
            f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// A switch statement to populate the plain_opname, op_symbol, and\n")
        f.write("// mpfr_func for all the unary ops that need a rounding mode.\n")
        f.write("#define GET_UNARY_OPS_ROUND_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == True):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Same as above, but for those that don't need a rounding mode.\n")
        f.write("#define GET_UNARY_OPS_NOROUND_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == False):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Same as above, but binary ops\n")
        f.write("#define GET_BINARY_OPS_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Same as above, but ternary ops\n")
        f.write("#define GET_TERNARY_OPS_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Call the wrapping macro, defined at the call site in hg_mathwrap.c,\n")
        f.write("// to wrap each function we support.\n")
        f.write("#define WRAP_UNARY_OPS \\\n")
        for op in ops:
            if (op.nargs == 1):
                f.write("  WRAP_UNARY({}, OP_{}); \\\n".format(op.func, op.func.upper()))
        f.write("\n")

        f.write("// Same for binary ops.\n")
        f.write("#define WRAP_BINARY_OPS \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("  WRAP_BINARY({}, OP_{}); \\\n".format(op.func, op.func.upper()))
        f.write("\n")

        f.write("// Same for binary ops.\n")
        f.write("#define WRAP_TERNARY_OPS \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("  WRAP_TERNARY({}, OP_{}); \\\n".format(op.func, op.func.upper()))
        f.write("\n")

        f.write("// Finally, define an enum for the operations we support.\n")
        f.write("typedef enum {\n")
        f.write("  // Unary functions\n")
        f.write("  UNARY_OPS_LIST\n")
        f.write("  // Binary\n")
        f.write("  BINARY_OPS_LIST\n")
        f.write("  // Ternary\n")
        f.write("  TERNARY_OPS_LIST\n")
        f.write("} OpType;\n")
        f.write("\n")

        f.write("#endif\n")

ops = []

def addOp(name, plain_name, nargs,
          hasfloat=True, mpfr_func=None, needsRound=True):
    mpfr_fn = "mpfr_" + name
    if (mpfr_func != None):
        mpfr_fn = mpfr_func

    ops.append(Op(name, plain_name, nargs,
                  mpfr_func=mpfr_fn,
                  needsround=needsRound))

    if hasfloat:
        ops.append(Op(name + "f",
                      plain_name + " (float)",
                      nargs,
                      mpfr_func=mpfr_fn,
                      needsround=needsRound))

addOp("sqrt", "square root", 1)
addOp("cbrt", "cube root", 1)

addOp("fabs", "absolute value", 1, mpfr_func="mpfr_abs")
addOp("logb", "get exponent", 1, mpfr_func="hiprec_logb")
addOp("rint", "round to nearest integer", 1)

addOp("ceil", "ceiling", 1, needsRound=False)
addOp("floor", "floor", 1, needsRound=False)
addOp("round", "round", 1, needsRound=False)
addOp("trunc", "truncate", 1, needsRound=False)

addOp("exp", "exponentiate", 1)
addOp("exp2", "base-two exponentiate", 1)
addOp("expm1", "exponentiate minus one", 1)
addOp("log", "log", 1)
addOp("log10", "log base ten", 1)
addOp("log1p", "plus one log", 1)
addOp("log2", "log base two", 1)

addOp("erf", "error function", 1)
addOp("erfc", "complementary error function", 1)
addOp("lgamma", "log gamma function", 1, mpfr_func="hiprec_lgamma")
addOp("tgamma", "gamma function", 1, mpfr_func="mpfr_gamma")
addOp("j0", "order zero first kind bessel function", 1)
addOp("j1", "order one first kind bessel function", 1)
addOp("y0", "order zero second kind bessel function", 1)
addOp("y1", "order one second kind bessel function", 1)

addOp("cos", "cosine", 1)
addOp("sin", "sine", 1)
addOp("tan", "tangent", 1)
addOp("asin", "arc sine", 1)
addOp("acos", "arc cosine", 1)
addOp("atan", "arc tangent", 1)

addOp("sinh", "hyperbolic sine", 1)
addOp("cosh", "hyperbolic cosine", 1)
addOp("tanh", "hyperbolic tangent", 1)
addOp("asinh", "hyperbolic arc sine", 1)
addOp("acosh", "hyperbolic arc cosine", 1)
addOp("atanh", "hyperbolic arc tangent", 1)

addOp("atan2", "arc tangent (two arguments)", 2)
addOp("hypot", "hypotenuse", 2)

addOp("pow", "power", 2)
addOp("fmod", "modulus", 2)
addOp("copysign", "copy sign", 2)
addOp("fdim", "positive difference", 2, mpfr_func="mpfr_dim")
addOp("fmax", "maximum", 2, mpfr_func="mpfr_max")
addOp("fmin", "minimum", 2, mpfr_func="mpfr_min")
addOp("remainder", "remainder", 2)

addOp("fma", "fused multiply-add", 3)

write_mathreplace_funcs(ops, "hg_mathreplace_funcs.h")
