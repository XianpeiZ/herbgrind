#!/usr/bin/env python

class Op(object):
    def __init__(self, func, plain_name, nargs, mpfr_func=None, needsround=True):
        self.func = func
        self.nargs = nargs
        self.plain_name = plain_name
        self.needsround = needsround
        if (mpfr_func == None):
            self.mpfr_func = "mpfr_{}".format(func)
        else:
            self.mpfr_func = mpfr_func

def write_mathreplace_funcs(ops, fname):
    with open(fname, "x") as f:
        f.write("#ifndef _HG_MATHREPLACE_FUNCS\n")
        f.write("#define _HG_MATHREPLACE_FUNCS\n")
        f.write("\n")
        f.write("// This monstrosity of a file sets up a lot of the machinery to\n")
        f.write("// replace libm functions called by client programs with a call into\n")
        f.write("// tool code which handles them properly. Basically, I wanted to make\n")
        f.write("// it very easy to add new libm functions without having to change\n")
        f.write("// code in like four different places. So I took every place you would\n")
        f.write("// have to change code to add new functions, and abstraced them away\n")
        f.write("// into macros, which all live in this file. This means the rest of\n")
        f.write("// the project is agnostic to which functions from libm we support,\n")
        f.write("// but it also means there are mysterious macros scattered throughout\n")
        f.write("// that code, and this file is a giant mess. Luckily, you should never\n")
        f.write("// actually touch it yourself, because it's instead generated by the\n")
        f.write("// mk_mathreplace.py python script.\n")
        f.write("\n")
        f.write("// These operations are based on the ones that Herbie supports natively.\n")
        f.write("\n")

        f.write("// A list of all the unary operations, for the enum definition farther\n")
        f.write("// down in the file.\n")
        f.write("#define UNARY_OPS_LIST \\\n")
        for op in ops:
            if (op.nargs == 1):
                f.write("  OP_{}, \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A list of all the binary ops comma seperated, for the enum\n")
        f.write("// definition farther down in the file.\n")
        f.write("#define BINARY_OPS_LIST \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("  OP_{}, \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A list of all the binary ops comma seperated, for the enum\n")
        f.write("// definition farther down in the file.\n")
        f.write("#define TERNARY_OPS_LIST \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("   OP_{}, \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A bunch of case statements for each unary op whose mpfr function\n")
        f.write("// doesn't need a rounding mode, used in runtime/hg_mathreplace.c\n")
        f.write("#define UNARY_OPS_ROUND_CASES \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == True):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// Same as above, but for those that don't need a rounding mode.\n")
        f.write("#define UNARY_OPS_NOROUND_CASES \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == False):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// For places where we don't care about the rounding mode.\n")
        f.write("#define UNARY_OPS_CASES                         \\\n")
        f.write("  UNARY_OPS_ROUND_CASES                         \\\n")
        f.write("  UNARY_OPS_NOROUND_CASES\n")
        f.write("\n")

        f.write("// The binary operation cases, used in runtime/hg_mathreplace.c\n")
        f.write("#define BINARY_OPS_CASES \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// The ternary operation cases, used in runtime/hg_mathreplace.c\n")
        f.write("#define TERNARY_OPS_CASES \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A switch statement to populate the plain_opname, op_symbol, and\n")
        f.write("// mpfr_func for all the unary ops that need a rounding mode.\n")
        f.write("#define GET_UNARY_OPS_ROUND_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == True):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      plain_opname = \"{}\"; \\\n".format(op.plain_name))
                f.write("      op_symbol = \"{}\"; \\\n".format(op.func))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Same as above, but for those that don't need a rounding mode.\n")
        f.write("#define GET_UNARY_OPS_NOROUND_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == False):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      plain_opname = \"{}\"; \\\n".format(op.plain_name))
                f.write("      op_symbol = \"{}\"; \\\n".format(op.func))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Same as above, but binary ops\n")
        f.write("#define GET_BINARY_OPS_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      plain_opname = \"{}\"; \\\n".format(op.plain_name))
                f.write("      op_symbol = \"{}\"; \\\n".format(op.func))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Same as above, but ternary ops\n")
        f.write("#define GET_TERNARY_OPS_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      plain_opname = \"{}\"; \\\n".format(op.plain_name))
                f.write("      op_symbol = \"{}\"; \\\n".format(op.func))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Call the wrapping macro, defined at the call site in hg_mathwrap.c,\n")
        f.write("// to wrap each function we support.\n")
        f.write("#define WRAP_UNARY_OPS \\\n")
        for op in ops:
            if (op.nargs == 1):
                f.write("  WRAP_UNARY({}, OP_{}); \\\n".format(op.func, op.func.upper()))
        f.write("\n")

        f.write("// Same for binary ops.\n")
        f.write("#define WRAP_BINARY_OPS \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("  WRAP_BINARY({}, OP_{}); \\\n".format(op.func, op.func.upper()))
        f.write("\n")

        f.write("// Same for binary ops.\n")
        f.write("#define WRAP_TERNARY_OPS \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("  WRAP_TERNARY({}, OP_{}); \\\n".format(op.func, op.func.upper()))
        f.write("\n")

        f.write("// Finally, define an enum for the operations we support.\n")
        f.write("typedef enum {\n")
        f.write("  // Unary functions\n")
        f.write("  UNARY_OPS_LIST\n")
        f.write("  // Binary\n")
        f.write("  BINARY_OPS_LIST\n")
        f.write("  // Ternary\n")
        f.write("  TERNARY_OPS_LIST\n")
        f.write("} OpType;\n")
        f.write("\n")

        f.write("#endif\n")

ops = [Op("sqrt", "square root", 1),
       Op("cbrt", "cube root", 1),
       Op("cbrtf", "cube root", 1, mpfr_func="mpfr_cbrt"),
       Op("exp", "exponentiate", 1),
       Op("log", "log", 1),
       Op("abs", "absolute value", 1),
       Op("expm1", "exponentiate minus one", 1),
       Op("log1p", "plus one log", 1),

       Op("erf", "error function", 1),
       Op("erff", "error function (float)", 1, mpfr_func="mpfr_erf"),
       Op("erfc", "complementary error function", 1),
       Op("erfcf", "complementary error function (float)", 1, mpfr_func="mpfr_erfc"),

       Op("cos", "cosine", 1),
       Op("cosf", "cosine (float)", 1, mpfr_func="mpfr_cos"),
       Op("sin", "sine", 1),
       Op("sinf", "sine (float)", 1, mpfr_func="mpfr_sin"),
       Op("tan", "tangent", 1),
       Op("tanf", "tangent (float)", 1, mpfr_func="mpfr_tan"),
       Op("asin", "arc sine", 1),
       Op("asinf", "arc sine (float)", 1, mpfr_func="mpfr_asin"),
       Op("acos", "arc cosine", 1),
       Op("acosf", "arc cosine (float)", 1, mpfr_func="mpfr_acos"),
       Op("atan", "arc tangent", 1),
       Op("atanf", "arc tangent (float)", 1, mpfr_func="mpfr_atan"),
       Op("sinh", "hyperbolic sine", 1),
       Op("sinhf", "hyperbolic sine (float)", 1, mpfr_func="mpfr_sinh"),
       Op("cosh", "hyperbolic cosine", 1),
       Op("coshf", "hyperbolic cosine (float)", 1, mpfr_func="mpfr_cosh"),
       Op("tanh", "hyperbolic tangent", 1),
       Op("tanhf", "hyperbolic tangent (float)", 1, mpfr_func="mpfr_tanh"),
       Op("asinh", "hyperbolic arc sine", 1),
       Op("asinhf", "hyperbolic arc sine (float)", 1, mpfr_func="mpfr_asinh"),
       Op("acosh", "hyperbolic arc cosine", 1),
       Op("acoshf", "hyperbolic arc cosine (float)", 1, mpfr_func="mpfr_acosh"),
       Op("atanh", "hyperbolic arc tangent", 1),
       Op("atanhf", "hyperbolic arc tangent (float)", 1, mpfr_func="mpfr_atanh"),

       Op("ceil", "ceiling", 1, needsround=False),
       Op("ceilf", "ceiling (float)", 1, needsround=False, mpfr_func="mpfr_ceil"),

       Op("mod", "modulus", 2, mpfr_func="mpfr_fmod"),
       Op("pow", "power", 2),
       Op("atan2", "arc tangent (two arguments)", 2),
       Op("atan2f", "arc tangent (two arguments, float)", 2, mpfr_func="mpfr_atan2"),
       Op("hypot", "hypotenuse", 2),
       Op("copysign", "copy sign", 2),
       Op("copysignf", "copy sign (float)", 2, mpfr_func="mpfr_copysign")]

write_mathreplace_funcs(ops, "hg_mathreplace_funcs.h")
