#!/usr/bin/env python

class Op(object):
    def __init__(self, func, plain_name, nargs, mpfr_func=None, needsround=True):
        self.func = func
        self.nargs = nargs
        self.plain_name = plain_name
        self.needsround = needsround
        if (mpfr_func == None):
            self.mpfr_func = "mpfr_{}".format(func)
        else:
            self.mpfr_func = mpfr_func

def write_mathreplace_funcs(ops, fname):
    with open(fname, "x") as f:
        f.write("#ifndef _HG_MATHREPLACE_FUNCS\n")
        f.write("#define _HG_MATHREPLACE_FUNCS\n")
        f.write("\n")
        f.write("// This monstrosity of a file sets up a lot of the machinery to\n")
        f.write("// replace libm functions called by client programs with a call into\n")
        f.write("// tool code which handles them properly. Basically, I wanted to make\n")
        f.write("// it very easy to add new libm functions without having to change\n")
        f.write("// code in like four different places. So I took every place you would\n")
        f.write("// have to change code to add new functions, and abstraced them away\n")
        f.write("// into macros, which all live in this file. This means the rest of\n")
        f.write("// the project is agnostic to which functions from libm we support,\n")
        f.write("// but it also means there are mysterious macros scattered throughout\n")
        f.write("// that code, and this file is a giant mess. Luckily, you should never\n")
        f.write("// actually touch it yourself, because it's instead generated by the\n")
        f.write("// mk_mathreplace.py python script.\n")
        f.write("\n")
        f.write("// These operations are based on the ones that Herbie supports natively.\n")
        f.write("\n")

        f.write("// A list of all the unary operations, for the enum definition farther\n")
        f.write("// down in the file.\n")
        f.write("#define UNARY_OPS_LIST \\\n")
        for op in ops:
            if (op.nargs == 1):
                f.write("  OP_{}, \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A list of all the binary ops comma seperated, for the enum\n")
        f.write("// definition farther down in the file.\n")
        f.write("#define BINARY_OPS_LIST \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("  OP_{}, \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A list of all the binary ops comma seperated, for the enum\n")
        f.write("// definition farther down in the file.\n")
        f.write("#define TERNARY_OPS_LIST \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("   OP_{}, \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A bunch of case statements for each unary op whose mpfr function\n")
        f.write("// doesn't need a rounding mode, used in runtime/hg_mathreplace.c\n")
        f.write("#define UNARY_OPS_ROUND_CASES \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == True):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// Same as above, but for those that don't need a rounding mode.\n")
        f.write("#define UNARY_OPS_NOROUND_CASES \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == False):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// For places where we don't care about the rounding mode.\n")
        f.write("#define UNARY_OPS_CASES                         \\\n")
        f.write("  UNARY_OPS_ROUND_CASES                         \\\n")
        f.write("  UNARY_OPS_NOROUND_CASES\n")
        f.write("\n")

        f.write("// The binary operation cases, used in runtime/hg_mathreplace.c\n")
        f.write("#define BINARY_OPS_CASES \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// The ternary operation cases, used in runtime/hg_mathreplace.c\n")
        f.write("#define TERNARY_OPS_CASES \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("  case OP_{}: \\\n".format(op.func.upper()))
        f.write("\n")

        f.write("// A switch statement to populate the plain_opname, op_symbol, and\n")
        f.write("// mpfr_func for all the unary ops that need a rounding mode.\n")
        f.write("#define GET_UNARY_OPS_ROUND_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == True):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      plain_opname = \"{}\"; \\\n".format(op.plain_name))
                f.write("      op_symbol = \"{}\"; \\\n".format(op.func))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Same as above, but for those that don't need a rounding mode.\n")
        f.write("#define GET_UNARY_OPS_NOROUND_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 1 and op.needsround == False):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      plain_opname = \"{}\"; \\\n".format(op.plain_name))
                f.write("      op_symbol = \"{}\"; \\\n".format(op.func))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Same as above, but binary ops\n")
        f.write("#define GET_BINARY_OPS_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      plain_opname = \"{}\"; \\\n".format(op.plain_name))
                f.write("      op_symbol = \"{}\"; \\\n".format(op.func))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Same as above, but ternary ops\n")
        f.write("#define GET_TERNARY_OPS_INFO(op) \\\n")
        f.write("  switch(op){ \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("    case OP_{}: \\\n".format(op.func.upper()))
                f.write("      plain_opname = \"{}\"; \\\n".format(op.plain_name))
                f.write("      op_symbol = \"{}\"; \\\n".format(op.func))
                f.write("      mpfr_func = {}; \\\n".format(op.mpfr_func))
                f.write("      break; \\\n")
        f.write("    default: \\\n")
        f.write("      return; \\\n")
        f.write("  }\n")
        f.write("\n")

        f.write("// Call the wrapping macro, defined at the call site in hg_mathwrap.c,\n")
        f.write("// to wrap each function we support.\n")
        f.write("#define WRAP_UNARY_OPS \\\n")
        for op in ops:
            if (op.nargs == 1):
                f.write("  WRAP_UNARY({}, OP_{}); \\\n".format(op.func, op.func.upper()))
        f.write("\n")

        f.write("// Same for binary ops.\n")
        f.write("#define WRAP_BINARY_OPS \\\n")
        for op in ops:
            if (op.nargs == 2):
                f.write("  WRAP_BINARY({}, OP_{}); \\\n".format(op.func, op.func.upper()))
        f.write("\n")

        f.write("// Same for binary ops.\n")
        f.write("#define WRAP_TERNARY_OPS \\\n")
        for op in ops:
            if (op.nargs == 3):
                f.write("  WRAP_TERNARY({}, OP_{}); \\\n".format(op.func, op.func.upper()))
        f.write("\n")

        f.write("// Finally, define an enum for the operations we support.\n")
        f.write("typedef enum {\n")
        f.write("  // Unary functions\n")
        f.write("  UNARY_OPS_LIST\n")
        f.write("  // Binary\n")
        f.write("  BINARY_OPS_LIST\n")
        f.write("  // Ternary\n")
        f.write("  TERNARY_OPS_LIST\n")
        f.write("} OpType;\n")
        f.write("\n")

        f.write("#endif\n")

ops = []

def addOp(name, plain_name, nargs,
          hasfloat=True, mpfr_func=None, needsRound=True):
    mpfr_fn = "mpfr_" + name
    if (mpfr_func != None):
        mpfr_fn = mpfr_func

    ops.append(Op(name, plain_name, nargs,
                  mpfr_func=mpfr_fn,
                  needsround=needsRound))

    if hasfloat:
        ops.append(Op(name + "f",
                      plain_name + " (float)",
                      nargs,
                      mpfr_func=mpfr_fn,
                      needsround=needsRound))

addOp("sqrt", "square root", 1)
addOp("cbrt", "cube root", 1)

addOp("fabs", "absolute value", 1, mpfr_func="mpfr_abs")
addOp("ceil", "ceiling", 1, needsRound=False)
addOp("floor", "floor", 1, needsRound=False)
addOp("round", "round", 1, needsRound=False)
addOp("trunc", "truncate", 1, needsRound=False)

addOp("exp", "exponentiate", 1)
addOp("exp2", "base-two exponentiate", 1)
addOp("expm1", "exponentiate minus one", 1)
addOp("log", "log", 1)
addOp("log10", "log base ten", 1)
addOp("log1p", "plus one log", 1)
addOp("log2", "log base two", 1)
addOp("erf", "error function", 1)
addOp("erfc", "complementary error function", 1)

addOp("cos", "cosine", 1)
addOp("sin", "sine", 1)
addOp("tan", "tangent", 1)
addOp("asin", "arc sine", 1)
addOp("acos", "arc cosine", 1)
addOp("atan", "arc tangent", 1)

addOp("sinh", "hyperbolic sine", 1)
addOp("cosh", "hyperbolic cosine", 1)
addOp("tanh", "hyperbolic tangent", 1)
addOp("asinh", "hyperbolic arc sine", 1)
addOp("acosh", "hyperbolic arc cosine", 1)
addOp("atanh", "hyperbolic arc tangent", 1)

addOp("atan2", "arc tangent (two arguments)", 2)
addOp("hypot", "hypotenuse", 2)

addOp("pow", "power", 2)
addOp("fmod", "modulus", 2)
addOp("copysign", "copy sign", 2)
addOp("fdim", "positive difference", 2, mpfr_func="mpfr_dim")
addOp("fmax", "maximum", 2, mpfr_func="mpfr_max")
addOp("fmin", "minimum", 2, mpfr_func="mpfr_min")
addOp("remainder", "remainder", 2)

addOp("fma", "fused multiply-add", 3)

write_mathreplace_funcs(ops, "hg_mathreplace_funcs.h")
